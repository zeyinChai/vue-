<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 官方说法
        // 1.key主要用在Vue虚拟算法,在新旧nodes对比时辨识Vnodes
        // 2.如果不使用key,Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法

        // 如果没有key 在源码中的流程是         效率比较低
        // 1.获取旧节点长度和新节点长度     对比获取最小的那个节点长度
        // 2.从小的的那个节点长度进行遍历     从新旧节点分别取值然后再patch函数中一一对比 替换进行更新
        // 3.如果旧节点数大于新节点数    对比更新完数据后 将大于的旧节点暴力删除
        // 4.如果新节点数大于旧节点数    对比更新完数据后 添加新的节点挂载
        //       如果长度最小的节点有100个元素每一个遍历进行对比  效率低


        // diff算法目的
        // 找出新旧dom树中有差的标签 然后重新渲染这个标签

        // 如果有key 在源码中的流程是
        // 1.从尾部和头部分布进行遍历
        // 2.比较vnode的时候 用类型和key进行比较 比如: n1.type和n1.key 与 n2.type和n2.key进行对比
        // 3.对比类型和key都相同的话 会进入对比内容patchNode
        // 4.如果内容不一样 以新节点为准 然后对比子节点

        // 新节点比较多             然后进行一次挂载
        // 旧节点比较多             然后进行一次卸载
        //      总结    使用key时 基于key的变化重新排列元素顺序
        //              key相同的话一般内容不变 就不管 然后把多出的内容进行 挂载或卸载即可


        // 尽量不要用index当做key   因为如果在中间或者开头插入新元素 会导致错误
    </script>
</body>
</html>